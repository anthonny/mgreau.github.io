<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="google-site-verification" content="EoXo80HtINVpGJQ5R7FQT-UhMzmvg6Lux-I_S6Wlhb8"><title>Java EE 7 et l&#8217;API Java pour WebSocket (JSR 356) | mgreau.com</title><link rel="stylesheet" href="/stylesheets/bootstrap.css"><link rel="stylesheet" href="/stylesheets/bootstrap-responsive.css"><link rel="stylesheet" href="/stylesheets/asciidoctor.css"><link rel="stylesheet" href="/stylesheets/asciidoctor-coderay.css"><link rel="stylesheet" href="/stylesheets/font-awesome.min.css"><link rel="stylesheet" href="/plugins/flexslider/flexslider.css"><link rel="stylesheet" href="/stylesheets/theme-style.css"><link rel="stylesheet" href="/stylesheets/alternative-colour.css"><link rel="stylesheet" href="/stylesheets/custom-style.css"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Condiment"><script src="/plugins/retina/retina.js"></script></head><body class="has-navbar-fixed-top page-index"><div class="wrapper" id="navigation"><div class="navbar navbar-fixed-top"><div class="navbar-inner"><div class="container">          <div class="brand"><h1><a href="/"><span class="em">[site.title]</span></a></h1></div><a class="mobile-toggle-trigger"><i class="icon-reorder"></i></a><a class="mobile-toggle-trigger scroll-nav" data-js="scroll-show"><i class="icon-reorder"></i></a><div class="mobile-toggle pull-right"><ul class="nav" id="main-menu"><li class=""><a href="/">About</a></li><li class=""><a href="/books.html">Books</a></li><li class=""><a href="/blog.html">Blog</a></li><li class=""><a href="/experience.html">Work / Experience</a></li><li class=""><a href="#contact" class="stamp">Contact</a></li>              </ul><g:plusone size="medium"></g:plusone><a href="https://twitter.com/share" class="twitter-share-button" data-lang="en">Tweet</a></div></div></div></div></div><div id="content"><div id="container"><article class="post"><header class="entry-header"><h1 class="title">Java EE 7 et l&#8217;API Java pour WebSocket (JSR 356)</h1><h4><time class="pubdate" datetime="2013-09-27T00:00:00+00:00">Friday, September 27, 2013</time></h4></header><div class="entry-content"></div><div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Cet article présente et met en oeuvre à travers un exemple concret et <a href="http://wildfly-mgreau.rhcloud.com/usopen/">disponible en ligne</a>, une des 4 nouvelles JSRs de <strong><a href="http://jcp.org/en/jsr/detail?id=342">Java EE 7</a></strong>, à savoir <strong><a href="http://jcp.org/en/jsr/detail?id=356">l&#8217;API Java pour communiquer via le protocole WebSocket (JSR 356)</a></strong>, .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Après la lecture de cet article, vous devriez être en mesure de comprendre la définition de ce qu&#8217;il est possible de faire avec le protocole WebSocket, donnée lors de Devoox UK par <a href="https://twitter.com/arungupta">Arun Gupta</a> :</p>
</div>
<div id="think" class="listingblock">
<div class="content">
<pre>WebSocket gives you bidirectionnal, full duplex, communication channel over a single TCP.</pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table des matières de l'article</div>
<ul class="sectlevel1">
<li><a href="#introduction-java-ee-7">Introduction à Java EE 7</a></li>
<li><a href="#demo-application-html5-jsr-356-api-d-ploy-e-sur-wildfly-8-openshift">DEMO : Application HTML5 / JSR-356 API déployée sur Wildfly 8 (OpenShift)</a></li>
<li><a href="#websocket-ws-un-nouveau-protocole-diff-rent-de-http">WebSocket (WS) : un nouveau protocole différent de HTTP</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#handshake">Handshake</a></li>
<li><a href="#data-transfer">Data transfer</a></li>
</ul>
</li>
<li><a href="#websocket-javascript-api-client">WebSocket Javascript API (Client)</a></li>
<li><a href="#jsr-386-java-api-pour-websocket">JSR 386 : Java API pour WebSocket</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#websocket-endpoint-serveur">WebSocket Endpoint : Serveur</a></li>
<li><a href="#annotations">Annotations</a></li>
<li><a href="#encoders-et-decoders">Encoders et Decoders</a></li>
<li><a href="#websocket-endpoint-client">WebSocket Endpoint : Client</a></li>
</ul>
</li>
<li><a href="#application-us-open">Application US OPEN</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#d-pendances-maven-java-ee-7">Dépendances Maven Java EE 7</a></li>
<li><a href="#cr-er-le-server-endpoint">Créer le Server Endpoint</a></li>
<li><a href="#encoder-et-d-coder-les-messages-chang-s">Encoder et Décoder les messages échangés</a></li>
<li><a href="#client-web-html5">Client Web HTML5</a></li>
<li><a href="#sources-de-l-exemple-sur-github">Sources de l&#8217;exemple sur Github</a></li>
<li><a href="#construire-et-d-ployer-le-war">Construire et Déployer le WAR</a></li>
</ul>
</li>
<li><a href="#performances-websocket-vs-rest">Performances : WebSocket vs REST</a></li>
<li><a href="#r-f-rences-pour-tout-savoir-sur-les-websocket">Références pour tout savoir sur les WebSocket</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="introduction-java-ee-7">Introduction à Java EE 7</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La <strong>Plateforme Java Entreprise Edition</strong> est sortie en version 7 (Java EE 7) au mois de Juin 2013.
Dans la continuité des versions Java EE 5 et Java EE 6, <strong>Java EE 7</strong> propose toujours de simplifier le travail du développeur.
Cette version agrémente les versions précédentes avec 3 objectifs principaux :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>s&#8217;interfacer avec <strong>HTML5</strong> (WebSocket API, JSON-P API, JAX-RS)</p>
</li>
<li>
<p>avoir une <strong>meilleure productivité</strong> (nouvelles annotations, moins de code inutile, meilleure cohésion entre JSRs)</p>
</li>
<li>
<p>répondre aux <strong>besoins des entreprises</strong> (Batch API, JMS API 2.0)</p>
</li>
</ul>
</div>
<div id="javaee7_intro" class="imageblock">
<div class="content">
<img src="/images/posts/javaee7_intro.png" alt="Java EE 7 - Objectifs">
</div>
<div class="title">Figure 1. Les 3 objectifs de Java EE 7</div>
</div>
<div class="paragraph">
<p>Java Platform, Entreprise Edition 7 (JSR 342), se résume donc autour de :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>4 nouvelles spécifications : <strong><code>Java API for WebSocket 1.0</code></strong>, <strong><code>Java API for JSON Processing 1.0</code></strong> , <strong><code>Batch Applications 1.0</code></strong> et <strong><code>Concurrency Utilities for Java EE 1.0</code></strong></p>
</li>
<li>
<p>3 spécifications avec une mise à jour majeure : <strong><code>JMS 2.0</code></strong>, <strong><code>JAX-RS 2.0</code></strong> et <strong><code>EL 3.0</code></strong></p>
</li>
<li>
<p>ainsi que 7 spécifications mises à jour dans une version mineure : <strong><code>JPA 2.1</code></strong>, <strong><code>Servlet 3.1</code></strong>, <strong><code>EJB 3.2</code></strong>, <strong><code>CDI 1.1</code></strong>, <strong><code>JSF 2.2</code></strong> et <strong><code>Bean Validation 1.1</code></strong></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="demo-application-html5-jsr-356-api-d-ploy-e-sur-wildfly-8-openshift">DEMO : Application HTML5 / JSR-356 API déployée sur Wildfly 8 (OpenShift)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Les plus impatients peuvent accéder à la <code><a href="http://wildfly-mgreau.rhcloud.com/usopen/">démonstration en ligne</a></code> du code qui va être, en partie, expliqué dans cet article.
Il s&#8217;agit d&#8217;une application qui permet :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>de suivre un match de Tennis en Live (Finale de l&#8217;US Open 20013) sans aucune action autre que la connexion à l&#8217;URL</p>
</li>
<li>
<p>de parier sur le vainqueur du match</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Vous allez me dire : "Rien d&#8217;extraordinaire !", et vous aurez raison.</p>
</div>
<div class="paragraph">
<p>A première vue, ce sont des choses que nous connaissons déjà sur beaucoup d&#8217;applications aujourd&#8217;hui, mais celle-ci est intéressante techniquement car comme vous le verrez au cours de l&#8217;article, tout est basé sur du <strong>standard autour du nouveau protocole WebSocket (ws:// ou wss://)</strong> et non sur du "hacking" de protocole HTTP.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Les technologies utilisées pour le developpement de cette application sont :</div>
<div class="ulist">
<ul>
<li>
<p>côté client : <code>HTML5</code>, <code>CSS</code>, <code>Javascript (WebSocket API)</code> avec <em>Bootstrap CSS mais sans JQuery ou BootstrapJS</em></p>
</li>
<li>
<p>côte serveur : <code>Java API for WebSocket</code>, <code>EJB</code>, <code>JSON-P</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="websocket_example" class="imageblock">
<div class="content">
<a class="image" href="http://wildfly-mgreau.rhcloud.com/usopen/"><img src="/images/posts/websocket_example.png" alt="Mise en oeuvre des WebSocket (Java API et Javascript API)"></a>
</div>
<div class="title">Figure 2. Mise en oeuvre des WebSocket (Java API et Javascript API)</div>
</div>
<div class="paragraph">
<p>Non cette démonstration n&#8217;est <strong>pas une application de chat :)</strong>
Il est évident que la démo "chat" est celle qui vient en premier à l&#8217;esprit pour illustrer l&#8217;utilisation de la technologie WebSocket. Néanmoins, il existe beaucoup d&#8217;autres cas d&#8217;utilisation, comme par exemple le travail collaboratif sur un document texte en ligne. Ou encore les jeux en ligne comme le jeu d'échec présenté lors de la <a href="https://blogs.oracle.com/javaone/entry/the_javaone_2013_technical_keynote">keynote de JavaOne 2013</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>Cette application est disponible sur le Cloud grâce à <a href="https://www.openshift.com/">OpenShift</a>, la solution Cloud de RedHat. Elle est déployée sur le serveur d&#8217;applications Wildfly 8.0.0-Beta3 (normalement certifié Java EE 7 fin 2013). Pour mettre en place un serveur de ce type, il suffit de suivre <a href="https://www.openshift.com/blogs/deploy-websocket-web-applications-with-jboss-wildfly">le post de Shekhar Gulati</a></em></p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-ws-un-nouveau-protocole-diff-rent-de-http">WebSocket (WS) : un nouveau protocole différent de HTTP</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://tools.ietf.org/html/rfc2616">HTTP</a> est le protocole standard utilisé pour le Web, il est très efficace pour certains cas d&#8217;utilisation mais il dispose néanmoins de <strong>quelques inconvénients</strong> dans le cas <strong>d&#8217;applications Web intéractives</strong> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>half-duplex</strong> : basé sur le pattern request/response, le client envoi une requête puis le serveur réalise un traitement avant de renvoyer une réponse, le client est donc contraint d&#8217;attendre une réponse du serveur</p>
</li>
<li>
<p><strong>verbose</strong> : beaucoup d&#8217;informations sont présentes avec les headers HTTP associés au message, aussi bien dans la requête HTTP que dans la réponse HTTP</p>
</li>
<li>
<p>pour faire du <strong>server push</strong>, il est nécessaire d&#8217;utiliser des méthodes de contournement (polling, long polling, Comet/Ajax) car il n&#8217;existe pas de standard.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ce protocole n&#8217;est donc pas optimisé pour scaler sur des applications qui ont d&#8217;important besoins de communication temps réel bi-directionnelle. C&#8217;est pourquoi le <strong>nouveau protocole WebSocket</strong> propose des fonctionnalités plus évoluées que HTTP, puisqu&#8217;il est :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>basé sur <strong><code>1 unique connexion TCP entre 2 peers</code></strong> (en HTTP chaque requête/réponse necessite une nouvelle connexion TCP)</p>
</li>
<li>
<p><strong><code>bi-directionnel</code></strong> : le client peut envoyer un message au serveur et le serveur peut envoyer un message au client</p>
</li>
<li>
<p><strong><code>full-duplex</code></strong> : le client peut envoyer plusieurs messages vers le serveur et le serveur vers le client sans attendre de réponse l&#8217;un de l&#8217;autre</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>Le terme <strong>client</strong> est utilisé uniquement pour définir celui qui va initialiser la connexion. Dès lors que la connexion est établie, le client et le serveur deviennent tous les deux des <strong><code>peers</code></strong>, avec les mêmes pouvoirs l&#8217;un par rapport à l&#8217;autre.</em></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Le protocole WebSocket devait à l&#8217;origine faire partie de la spécification HTML5 mais comme celle-ci sortira officiellement en 2014, il est finalement défini, au même titre que HTTP, par une spécification IETF, <a href="http://tools.ietf.org/html/rfc6455">la RFC 6455</a>.</p>
</div>
<div class="paragraph">
<p>Comme le montre le schéma ci-après, le <strong>protocole WebSocket fonctionne en 2 phases</strong> nommées :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong><code>handshake</code></strong></p>
</li>
<li>
<p><strong><code>data transfer</code></strong></p>
</li>
</ol>
</div>
<div id="websocket_protocol" class="imageblock">
<div class="content">
<img src="/images/posts/WebSocket_Protocol.png" alt="Schéma d'explications du protocole WebSocket" width="550">
</div>
<div class="title">Figure 3. Explication du protocole WebSocket</div>
</div>
<div class="sect2">
<h3 id="handshake">Handshake</h3>
<div class="paragraph">
<p>La phase nommée <strong>Handshake</strong> correspond à un <strong>unique échange requête/réponse HTTP</strong> entre l&#8217;initiateur de la connexion (peer client)  et le peer serveur. Cet échange HTTP est spécifique car il utilise la notion <a href="http://tools.ietf.org/html/rfc2616#section-14.42"><strong>d&#8217;Upgrade, définie dans la spécification HTTP</strong>.</a><br>
Le principe est simple : <strong>l&#8217;Upgrade HTTP</strong> permet au client de communiquer avec le serveur pour lui demander de changer de protocole de communication et ainsi faire en sorte que le client et le serveur utilisent un protocole autre que HTTP pour discuter.</p>
</div>
<div id="eg1-callouts" class="exampleblock">
<div class="title">Example 1. Exemple de Requête HTTP Handshake</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="text language-text">GET /usopen/matches/1234 HTTP/1.1     <i class="conum" data-value="1"></i><b>(1)</b>&#10;Host: wildfly-mgreau.rhcloud.com:8000  <i class="conum" data-value="2"></i><b>(2)</b>&#10;Upgrade: websocket  <i class="conum" data-value="3"></i><b>(3)</b>&#10;Connection: Upgrade <i class="conum" data-value="4"></i><b>(4)</b>&#10;Origin: http://wildfly-mgreau.rhcloud.com&#10;Sec-WebSocket-Key:0EK7XmpTZL341oOh7x1cDw==&#10;Sec-WebSocket-Version:13</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Methode HTTP GET et version 1.1 obligatoires</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Host utilisé pour la connexion WebSocket</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Demande d&#8217;Upgrade vers le protocole WebSocket</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Demande d&#8217;Upgrade HTTP pour changer de protocole</td>
</tr>
</table>
</div>
</div>
</div>
<div id="eg2-callouts" class="exampleblock">
<div class="title">Example 2. Exemple de Réponse HTTP Handshake</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="text language-text">HTTP/1.1 101 Switching Protocols <i class="conum" data-value="1"></i><b>(1)</b>&#10;Connection:Upgrade&#10;Sec-WebSocket-Accept:SuQ5/hh0kStSr6oIzDG6gRfTx2I=&#10;Upgrade:websocket <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Code HTTP 101, le serveur est compatible et accepte le changement de protocole</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>L&#8217;upgrade vers le protocole WebSocket est accepté</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>Lorsque la demande d&#8217;upgrade du protocole HTTP vers le protocole Web Socket a été validée par le serveur endpoint, il n&#8217;y a plus de communication possible en HTTP, tous les échanges sont réalisés via le protocole WebSocket.</em></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="data-transfer">Data transfer</h3>
<div class="paragraph">
<p>Une fois que le <strong>handshake</strong> est acceptée, la mise en place du protocole WebSocket est donc acquise. Une connexion côté <em>peer server</em> est ouverte ainsi que côté <em>peer client</em>, une gestion de callback est activée pour initier la communication.<br>
La phase de <strong>Data transfer</strong> peut alors entrer en jeu, c&#8217;est-à-dire que les 2 peers peuvent désormais <strong>s'échanger des messages dans une communication bi-directionnelle et full-duplex</strong>.<br></p>
</div>
<div class="paragraph">
<p>Comme le montre le schéma de la <strong>Figure 3</strong>, le <code>peer server</code> peut envoyer plusieurs messages (dans l&#8217;exemple : 1 message à chaque point du match) sans aucune réponse du <code>peer client</code> qui, lui, peut également envoyer des messages à n&#8217;importe quel moment (dans l&#8217;exemple : le pari sur le vainqueur du match).
Chaque peer peut envoyer un message spécifique afin de clôturer la connexion.<br></p>
</div>
<div class="paragraph">
<p>Dans Java EE7, le code côté <code>peer server</code> est en <strong>Java</strong> alors que le code côté <code>peer client</code> est en <strong>Java ou en Javascript</strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket-javascript-api-client">WebSocket Javascript API (Client)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Pour communiquer à partir d&#8217;une application Web avec un serveur en utilisant le protocole WebSocket, il est nécessaire d&#8217;utiliser <strong>une API cliente en Javascript</strong>. C&#8217;est le W3C qui définit cette API.<br>
La spécification W3C de cette <a href="http://w3.org/TR/websockets/">API Javascript pour WebSocket</a> est en cours de finalisation. <a href="http://www.w3.org/TR/websockets/#websocket">L&#8217;interface WebSocket</a> propose, entre-autres, les éléments suivants :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>un attribut pour l&#8217;URL de connexion au server Endpoint (<code>url</code>)</p>
</li>
<li>
<p>un attribut sur l'état de la connexion (<code>readyState</code> : CONNECTING, OPEN, CLOSING, CLOSED)</p>
</li>
<li>
<p>des <strong>Event-Handler (gestionnaire d'évènement)</strong> pour s&#8217;adapter aux méthodes du cycle de vie des WebSocket, par exemple :</p>
<div class="ulist">
<ul>
<li>
<p>l&#8217;Event-Handler <code>onopen</code> est appelé lorsqu&#8217;une nouvelle connexion est initiée</p>
</li>
<li>
<p>l&#8217;Event-Handler <code>onerror</code> est appelé lorsqu&#8217;une erreur est reçue pendant la communication</p>
</li>
<li>
<p>l&#8217;Event-Handler <code>onmessage</code> est appelé lorsqu&#8217;un message est reçu</p>
</li>
</ul>
</div>
</li>
<li>
<p>les méthodes (<code>send(DOMString data)</code>, <code>send(Blob data)</code>) avec lesquelles il est possible d&#8217;envoyer différents types de flux (texte, binaire) vers le serveur Endpoint</p>
</li>
</ul>
</div>
<div id="eg3-callouts" class="exampleblock">
<div class="title">Example 3. Exemple de code Javascript, issue de <a href="http://websocket.org">http://websocket.org</a></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span style="color:#080;font-weight:bold">var</span> wsUri = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ws://echo.websocket.org/</span><span style="color:#710">&quot;</span></span>;&#10;&#10;<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">testWebSocket</span>() {&#10;&#10;        websocket = <span style="color:#080;font-weight:bold">new</span> WebSocket(wsUri);&#10;        websocket.<span style="color:#06B;font-weight:bold">onopen</span> = <span style="color:#080;font-weight:bold">function</span>(evt) { onOpen(evt) };&#10;        websocket.<span style="color:#06B;font-weight:bold">onclose</span> = <span style="color:#080;font-weight:bold">function</span>(evt) { onClose(evt) };&#10;        websocket.<span style="color:#06B;font-weight:bold">onmessage</span> = <span style="color:#080;font-weight:bold">function</span>(evt) { onMessage(evt) };&#10;        websocket.<span style="color:#06B;font-weight:bold">onerror</span> = <span style="color:#080;font-weight:bold">function</span>(evt) { onError(evt) }; }&#10;}&#10;&#10;<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">onOpen</span>(evt) {&#10;        writeToScreen(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">CONNECTED</span><span style="color:#710">&quot;</span></span>);&#10;        doSend(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">WebSocket rocks</span><span style="color:#710">&quot;</span></span>);&#10;}&#10;<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">onClose</span>(evt) {&#10;        writeToScreen(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">DISCONNECTED</span><span style="color:#710">&quot;</span></span>);&#10;}&#10;<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">onMessage</span>(evt) {&#10;        writeToScreen(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">&lt;span style=&quot;color: blue;&quot;&gt;RESPONSE: </span><span style="color:#710">'</span></span> + evt.data+<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">&lt;/span&gt;</span><span style="color:#710">'</span></span>);&#10;        websocket.close();&#10;}&#10;&#10;<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">onError</span>(evt) {&#10;        writeToScreen(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">&lt;span style=&quot;color: red;&quot;&gt;ERROR:&lt;/span&gt; </span><span style="color:#710">'</span></span> + evt.data);&#10;}&#10;<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">doSend</span>(message) {&#10;        writeToScreen(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">SENT: </span><span style="color:#710">&quot;</span></span> + message);&#10;        websocket.send(message);&#10;}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jsr-386-java-api-pour-websocket">JSR 386 : Java API pour WebSocket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Le W3C définit donc comment utiliser WebSocket en Javascript, le <strong>Java Communitee Process (JCP)</strong> fait de même pour le monde Java via la JSR 386 .<br>
La JSR 356 définit ainsi une <a href="http://jcp.org/en/jsr/detail?id=356">API Java pour WebSocket</a> qui propose :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>la création d&#8217;un <code><strong>WebSocket Endpoint</strong></code> (serveur ou client), nom donné au composant Java capable de communiquer via le protocole WebSocket</p>
</li>
<li>
<p>la possibilité d&#8217;utiliser l&#8217;approche par <strong>annotation Java</strong> ou par programmation</p>
</li>
<li>
<p>la possibilité <strong>d&#8217;envoyer et de consommer des messages</strong> de contrôles, textuels ou binaires via ce protocole</p>
<div class="ulist">
<ul>
<li>
<p>de gérer le message en tant que message complet ou par une séquence de messages partiels</p>
</li>
<li>
<p>envoyer ou recevoir les messages en tant qu&#8217;objets Java (notion d'<strong>encoders/decoders</strong>)</p>
</li>
<li>
<p>envoyer les messages <strong>en synchrone ou en asynchrone</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>la configuration et la <strong>gestion des sessions WebSocket</strong> (timeout, cookies&#8230;)</p>
</li>
<li>
<p>une intégration dans <strong>Java EE Web Profile</strong></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<em>L&#8217;implémentation de référence Java pour l&#8217;API WebSocket est <a href="https://tyrus.java.net/">le projet Tyrus</a></em>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="websocket-endpoint-serveur">WebSocket Endpoint : Serveur</h3>
<div class="paragraph">
<p>La transformation d&#8217;un Plain Old Java Object (POJO) vers un <strong>WebSocket Endpoint</strong> de type serveur (c&#8217;est-à-dire capable de gérer des requêtes de plusieurs clients sur une même URI) est <strong>extrêment simple</strong>, puisqu&#8217;il suffit d&#8217;annoter la classe avec <strong>@ServerEndpoint</strong> et une méthode du POJO avec <strong>@OnMessage</strong> :</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="java language-java"><span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">javax.websocket.OnMessage</span>;&#10;<span style="color:#080;font-weight:bold">import</span> <span style="color:#B44;font-weight:bold">javax.websocket.ServerEndpoint</span>;&#10;&#10;<span style="color:#007">@ServerEndpoint</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">/echo</span><span style="color:#710">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>&#10;<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">EchoServer</span> {&#10;&#10;        <span style="color:#007">@OnMessage</span> <i class="conum" data-value="2"></i><b>(2)</b>&#10;        <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a5;font-weight:bold">String</span> handleMessage(<span style="color:#0a5;font-weight:bold">String</span> message){&#10;                <span style="color:#080;font-weight:bold">return</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Thanks for the message: </span><span style="color:#710">&quot;</span></span> + message;&#10;        }&#10;&#10;}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>L&#8217;annotation @ServerEndpoint transforme le POJO en WebSocket Endpoint, l&#8217;attribut <strong>value</strong> est obligatoire afin de préciser l&#8217;URI d&#8217;accès à cet Endpoint</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>la méthode handleMessage sera évoquée lors de chaque message reçu</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="annotations">Annotations</h3>
<div class="paragraph">
<p>L&#8217;API met à disposition plusieurs types d&#8217;annotations afin d'être entièrement compatible avec le procotole WebSocket :</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation</th>
<th class="tableblock halign-left valign-top">Rôle</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@ServerEndpoint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Déclare un Server Endpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@ClientEndpoint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Déclare un Client Endpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@OnOpen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Défini la méthode appelée pour gérer l'évenement d&#8217;ouverture de la connexion</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@OnMessage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Défini la méthode appelée pour gérer l'évenement de réception d&#8217;un message</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@OnError</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Défini la méthode appelée pour gérer l'évenement lors d&#8217;une erreur</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@OnClose</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Défini la méthode appelée pour gérer l'évenement de clôture de la connexion</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>Les attributs de l&#8217;annotation <code>@ServerEndpoint</code> sont les suivants :</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">value</dt>
<dd>
<p>URI relative ou URI template (ex: "/echo", "/chat/{subscriver-level}")</p>
</dd>
<dt class="hdlist1">decoders</dt>
<dd>
<p>liste de noms de classes utilisées pour décoder les messages entrants</p>
</dd>
<dt class="hdlist1">encoders</dt>
<dd>
<p>liste de noms de classes utilisées pour encoder les messages sortants</p>
</dd>
<dt class="hdlist1">subprotocols</dt>
<dd>
<p>liste de sous-protocoles autorisés (ex: <a href="http://wamp.ws)">http://wamp.ws)</a></p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="encoders-et-decoders">Encoders et Decoders</h3>
<div class="paragraph">
<p>Comme il a été décrit plus tôt dans cet article, le serveur Endpoint peut recevoir différents types de contenu dans les messages : des données au format texte (JSON, XML&#8230;) ou au format binaire.<br>
Afin de gérer efficacement les messages provenant des <em>peers client</em> ou à destination de ceux-ci dans le code métier de l&#8217;application, il est possible de créer des classes Java de type <strong>Decoders et Encoders</strong>.</p>
</div>
<div class="paragraph">
<p>Quelque soit l&#8217;algorithme de transformation, il va alors être possible de transformer  :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>le POJO métier vers un flux au format désiré pour l&#8217;envoi (JSON, XML, Binaire&#8230;)</p>
</li>
<li>
<p>les flux entrants dans format spécifique (JSON, XML..) vers le POJO métier</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ainsi, le code de l&#8217;application est organisé de telle façon que la logique métier n&#8217;est pas impactée par le type et le format de flux échangés entre le <em>peer serveur</em> et les <em>peers clients</em>.
Un exemple concret est présenté dans la suite de l&#8217;article.</p>
</div>
</div>
<div class="sect2">
<h3 id="websocket-endpoint-client">WebSocket Endpoint : Client</h3>
<div class="paragraph">
<p>L&#8217;API propose donc également le support pour créer des Endpoints côté client en Java.</p>
</div>
<div id="eg4-callouts" class="exampleblock">
<div class="title">Example 4. Exemple de Client Endpoint en Java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="java language-java"><span style="color:#007">@ClientEndpoint</span>&#10;<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">HelloClient</span> {&#10;&#10;        <span style="color:#007">@OnMessage</span>&#10;        <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a5;font-weight:bold">String</span> message(<span style="color:#0a5;font-weight:bold">String</span> message){&#10;                <span style="color:#777">// traitement</span>&#10;        }&#10;}&#10;&#10;WebSocketContainer c = ContainerProvider.getWebSocketContainer();&#10;c.connectToServer(HelloClient.class, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">hello</span><span style="color:#710">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="application-us-open">Application US OPEN</h2>
<div class="sectionbody">
<div class="paragraph">
<p>L&#8217;application exemple est déployée sous forme de WAR issue d&#8217;un projet Apache Maven.
Outre la gestion classique du cycle de vie WebSocket, le workflow d&#8217;envoi de messages est le suivant :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>à chaque point du match, les <em>peers clients</em> recoivent les données du match (score, service&#8230;)</p>
</li>
<li>
<p>le <em>peer client</em> peut envoyer un message pour parier sur le gagnant du match</p>
</li>
<li>
<p>à la fin du match, les <em>peers clients</em> reçoivent un message contenant le nom du vainqueur</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Tous les messages sont échangés au format JSON.</strong><br></p>
</div>
<div class="paragraph">
<p>L&#8217;arborescence du projet est la suivante :</p>
</div>
<div id="eg5-callouts" class="exampleblock">
<div class="title">Example 5. Structure du projet Maven</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="text language-text">+ src/main/java&#10;   |+ com.mgreau.wildfly.websocket&#10;      |+ decoders&#10;         |- MessageDecoder.java   <i class="conum" data-value="1"></i><b>(1)</b>&#10;      |+ encoders       <i class="conum" data-value="2"></i><b>(2)</b>&#10;         |- BetMessageEncoder.java&#10;         |- MatchMessageEncoder.java&#10;      |+ messages       <i class="conum" data-value="3"></i><b>(3)</b>&#10;         |- BetMessage.java&#10;         |- MatchMessage.java&#10;         |- Message.java&#10;      |- MatchEndpoint.java    <i class="conum" data-value="4"></i><b>(4)</b>&#10;      |- StarterService.java   <i class="conum" data-value="5"></i><b>(5)</b>&#10;      |- TennisMatch.java      <i class="conum" data-value="6"></i><b>(6)</b>&#10;+ src/main/resources&#10;+ scr/main/webapp&#10;   |+ css&#10;   |+ images&#10;   |- index.html&#10;   |- websocket.js  <i class="conum" data-value="7"></i><b>(7)</b>&#10;pom.xml</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Decode le message JSON provenant du <em>peer client</em> concernant le pari sur le vainqueur en POJO (<em>BetMessage</em>)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Encode à destination des <em>peers clients</em>, en JSON (via JSON-P), les messages contenant le détail du match et le résultat du pari sur le vainqueur</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>POJOs représentant les types de messages échangés entre peers</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>WebSocket Server Endpoint de l&#8217;application (<em>peer server</em>)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>EJB @Startup permettant d&#8217;initialiser l&#8217;application lors du déploiement</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>POJO pour gérer les informations du match</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Fichier Javascript pour la communication WebSocket du <em>peer client</em> via l&#8217;API Javascript</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="d-pendances-maven-java-ee-7">Dépendances Maven Java EE 7</h3>
<div id="eg6-callouts" class="exampleblock">
<div class="title">Example 6. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="xml language-xml"><span style="color:#070">&lt;project&gt;</span>&#10;...&#10;<span style="color:#070">&lt;properties&gt;</span>&#10;        <span style="color:#070">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span style="color:#070">&lt;/project.build.sourceEncoding&gt;</span>&#10;        <span style="color:#777">&lt;!-- Java EE 7 --&gt;</span>&#10;        <span style="color:#070">&lt;javaee.api.version&gt;</span>7.0<span style="color:#070">&lt;/javaee.api.version&gt;</span>&#10;<span style="color:#070">&lt;/properties</span>&#10;&#10;<span style="color:#070">&lt;dependencies&gt;</span>&#10;        <span style="color:#070">&lt;dependency&gt;</span>&#10;                <span style="color:#070">&lt;groupId&gt;</span>javax<span style="color:#070">&lt;/groupId&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>&#10;                <span style="color:#070">&lt;artifactId&gt;</span>javaee-api<span style="color:#070">&lt;/artifactId&gt;</span>&#10;                <span style="color:#070">&lt;version&gt;</span>${javaee.api.version}<span style="color:#070">&lt;/version&gt;</span>&#10;                <span style="color:#070">&lt;scope&gt;</span>provided<span style="color:#070">&lt;/scope&gt;</span>&#10;        <span style="color:#070">&lt;/dependency&gt;</span>&#10;<span style="color:#070">&lt;/dependencies&gt;</span>&#10;...&#10;<span style="color:#070">&lt;/project&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>il est important d&#8217;utiliser les dépendances de la spécification Java EE 7 afin de pouvoir déployer l&#8217;application dans plusieurs serveurs d&#8217;applications Java EE sans changement de code (Wildfly, Glassfish&#8230;)</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cr-er-le-server-endpoint">Créer le Server Endpoint</h3>
<div class="paragraph">
<p>Cet Endpoint permet de recevoir les messages concernant les paris sur le vainqueur du match et également d&#8217;envoyer aux <em>peers clients</em> les informations du déroulement du match.</p>
</div>
<div id="eg7-callouts" class="exampleblock">
<div class="title">Example 7. Server Endpoint : MatchEndpoint.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="java language-java"><span style="color:#007">@ServerEndpoint</span>(&#10;                value = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">/matches/{match-id}</span><span style="color:#710">&quot;</span></span>,  <i class="conum" data-value="1"></i><b>(1)</b>&#10;                        decoders = { MessageDecoder.class }, <i class="conum" data-value="2"></i><b>(2)</b>&#10;                        encoders = { MatchMessageEncoder.class, BetMessageEncoder.class } <i class="conum" data-value="3"></i><b>(3)</b>&#10;                )&#10;<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MatchEndpoint</span> {&#10;&#10;        <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a5;font-weight:bold">Logger</span> logger = <span style="color:#0a5;font-weight:bold">Logger</span>.getLogger(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">MatchEndpoint</span><span style="color:#710">&quot;</span></span>);&#10;&#10;        <span style="color:#777">/* Queue for all open WebSocket sessions */</span>&#10;        <span style="color:#088;font-weight:bold">static</span> <span style="color:#0a5;font-weight:bold">Queue</span>&lt;Session&gt; queue = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a5;font-weight:bold">ConcurrentLinkedQueue</span>&lt;&gt;();&#10;&#10;        <span style="color:#007">@OnOpen</span>&#10;        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> openConnection(Session session,&#10;                                <span style="color:#007">@PathParam</span>(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">match-id</span><span style="color:#710">&quot;</span></span>) <span style="color:#0a5;font-weight:bold">String</span> matchId) {        <i class="conum" data-value="4"></i><b>(4)</b>&#10;            <span style="color:#777">/* Register this connection in the queue */</span>&#10;            queue.add(session);&#10;            session.getUserProperties().put(matchId, <span style="color:#069">true</span>);&#10;            logger.log(<span style="color:#0a5;font-weight:bold">Level</span>.INFO, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Connection opened for game : </span><span style="color:#710">&quot;</span></span> + matchId);&#10;        }&#10;&#10;        <span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">void</span> send(MatchMessage msg, <span style="color:#0a5;font-weight:bold">String</span> matchId) {&#10;          <span style="color:#080;font-weight:bold">try</span> {&#10;            <span style="color:#777">/* Send updates to all open WebSocket sessions for this match */</span>&#10;            <span style="color:#080;font-weight:bold">for</span> (Session session : queue) {&#10;              <span style="color:#080;font-weight:bold">if</span> (<span style="color:#0a5;font-weight:bold">Boolean</span>.TRUE.equals(session.getUserProperties().get(matchId))){&#10;                <span style="color:#080;font-weight:bold">if</span> (session.isOpen()){&#10;                      session.getBasicRemote().sendObject(msg);        <i class="conum" data-value="5"></i><b>(5)</b>&#10;                      logger.log(<span style="color:#0a5;font-weight:bold">Level</span>.INFO, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Score Sent: {0}</span><span style="color:#710">&quot;</span></span>, msg);&#10;                }&#10;              }&#10;            }&#10;          } <span style="color:#080;font-weight:bold">catch</span> (<span style="color:#C00;font-weight:bold">IOException</span> | EncodeException e) {&#10;            logger.log(<span style="color:#0a5;font-weight:bold">Level</span>.INFO, e.toString());&#10;          }&#10;        }&#10;&#10;        <span style="color:#007">@OnMessage</span>&#10;        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> message(<span style="color:#088;font-weight:bold">final</span> Session session, BetMessage msg) {        <i class="conum" data-value="6"></i><b>(6)</b>&#10;            logger.log(<span style="color:#0a5;font-weight:bold">Level</span>.INFO, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Received: Bet Match Winner - {0}</span><span style="color:#710">&quot;</span></span>, msg.getWinner());&#10;            session.getUserProperties().put(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">betMatchWinner</span><span style="color:#710">&quot;</span></span>, msg);&#10;        }&#10;...&#10;}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>URI pour accéder à cet Endpoint, comme le context-root de l&#8217;application est <em>/usopen</em>, un exemple d&#8217;URL est <code>ws://&lt;host&gt;:&lt;port&gt;/usopen/matches/1234</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>la classe <em>MessageDecoder</em> permet de transformer le flux JSON entrant pour le pari sur le vainqueur en POJO <em>BetMessage</em></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>les 2 encodeurs permettent de transformer les POJO <em>MatchMessage</em> et <em>BetMessage</em> en flux JSON</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>l&#8217;annotation <code>@PathParam</code> permet ici d&#8217;extraire l'élément de la requête WS et de passer la valeur (identifiant du match) en paramètre de la méthode, il est ainsi possible de gérer plusieurs matchs avec des clients différents pour chaque match.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Envoi du message concernant le match aux peers connectés, grâce à l'<em>Encoder</em> il suffit de passer en paramètre un objet <em>MatchMessage</em></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Gestion de la réception des messages de pari sur le vainqueur du match, grâce au <em>Decoder</em> la méthode prend en paramètre un objet <em>BetMessage</em></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="encoder-et-d-coder-les-messages-chang-s">Encoder et Décoder les messages échangés</h3>
<div class="paragraph">
<p>Pour encoder ou décoder les messages échangés entre peers, il suffit d&#8217;implémenter l&#8217;interface adéquate selon le type de message (Texte, Binaire) et le sens de traitement (encodage, décodage), puis de redéfinir la méthode associée.<br>
Dans l&#8217;exemple ci-dessous, il s&#8217;agit de l&#8217;encodeur pour le POJO MatchMessage vers le format JSON. L&#8217;API utilisée pour réaliser ce traitement est une des nouvelles API de Java EE 7 : <a href="http://jcp.org/en/jsr/detail?id=353">Java API for JSON Processiong (JSON-P)</a></p>
</div>
<div id="eg8-callouts" class="exampleblock">
<div class="title">Example 8. src/main/java/com/mgreau/wildfly/websocket/encoders/MatchMessageEncoder.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="java language-java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">MatchMessageEncoder</span> <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a5;font-weight:bold">Encoder</span>.Text&lt;MatchMessage&gt; {&#10;&#10;        <span style="color:#007">@Override</span>&#10;        <span style="color:#088;font-weight:bold">public</span> <span style="color:#0a5;font-weight:bold">String</span> encode(MatchMessage m) <span style="color:#088;font-weight:bold">throws</span> EncodeException {&#10;                <span style="color:#0a5;font-weight:bold">StringWriter</span> swriter = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a5;font-weight:bold">StringWriter</span>();&#10;                <span style="color:#080;font-weight:bold">try</span> (JsonWriter jsonWrite = Json.createWriter(swriter)) {&#10;                        JsonObjectBuilder builder = Json.createObjectBuilder();&#10;                        builder.add(&#10;                                <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">match</span><span style="color:#710">&quot;</span></span>,&#10;                                Json.createObjectBuilder()&#10;                                        .add(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">serve</span><span style="color:#710">&quot;</span></span>, m.getMatch().getServe())&#10;                                        .add(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">title</span><span style="color:#710">&quot;</span></span>, m.getMatch().getTitle())&#10;                                        ...&#10;                        }&#10;&#10;                        jsonWrite.writeObject(builder.build());&#10;                }&#10;                <span style="color:#080;font-weight:bold">return</span> swriter.toString();&#10;        }&#10;}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-web-html5">Client Web HTML5</h3>
<div class="paragraph">
<p>L&#8217;unique page HTML de cette application charge le fichier <strong>websocket.js</strong> pour mettre en oeuvre l&#8217;API Javascript WebSocket et ainsi intéragir avec le Server Endpoint Java.</p>
</div>
<div id="eg9-callouts" class="exampleblock">
<div class="title">Example 9. API Javascript : websocket.js</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay nowrap"><code class="javascript language-javascript"><span style="color:#080;font-weight:bold">var</span> wsUrl;&#10;<span style="color:#080;font-weight:bold">if</span> (window.location.protocol == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">https:</span><span style="color:#710">'</span></span>) {  <i class="conum" data-value="1"></i><b>(1)</b>&#10;        wsUrl = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">wss://</span><span style="color:#710">'</span></span> + window.location.host + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">:8443/usopen/matches/1234</span><span style="color:#710">'</span></span>;&#10;} <span style="color:#080;font-weight:bold">else</span> {&#10;        wsUrl = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ws://</span><span style="color:#710">'</span></span> + window.location.host + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">:8000/usopen/matches/1234</span><span style="color:#710">'</span></span>;&#10;}&#10;&#10;<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">createWebSocket</span>(host) {&#10;        <span style="color:#080;font-weight:bold">if</span> (!window.WebSocket) {    <i class="conum" data-value="2"></i><b>(2)</b>&#10;        ...&#10;        } <span style="color:#080;font-weight:bold">else</span> {&#10;                socket = <span style="color:#080;font-weight:bold">new</span> WebSocket(host);   <i class="conum" data-value="3"></i><b>(3)</b>&#10;                socket.<span style="color:#06B;font-weight:bold">onopen</span> = <span style="color:#080;font-weight:bold">function</span>() {&#10;                        document.getElementById(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">m1-status</span><span style="color:#710">&quot;</span></span>).innerHTML = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">CONNECTED...</span><span style="color:#710">'</span></span>;&#10;                };&#10;                socket.<span style="color:#06B;font-weight:bold">onclose</span> = <span style="color:#080;font-weight:bold">function</span>() {&#10;                        document.getElementById(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">m1-status</span><span style="color:#710">&quot;</span></span>).innerHTML = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">FINISHED</span><span style="color:#710">'</span></span>;&#10;                };&#10;                ...&#10;                socket.<span style="color:#06B;font-weight:bold">onmessage</span> = <span style="color:#080;font-weight:bold">function</span>(msg) {&#10;                        <span style="color:#080;font-weight:bold">try</span> {&#10;                                console.log(data);&#10;                                <span style="color:#080;font-weight:bold">var</span> obj = JSON.parse(msg.data);     <i class="conum" data-value="4"></i><b>(4)</b>&#10;                                <span style="color:#080;font-weight:bold">if</span> (obj.hasOwnProperty(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">match</span><span style="color:#710">&quot;</span></span>)){   <i class="conum" data-value="5"></i><b>(5)</b>&#10;                                        <span style="color:#777">//title</span>&#10;                                        m1title.innerHTML = obj.match.title;&#10;                                        <span style="color:#777">// comments</span>&#10;                                        m1comments.value = obj.match.comments;&#10;                                        <span style="color:#777">// serve</span>&#10;                                        <span style="color:#080;font-weight:bold">if</span> (obj.match.serve === <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">player1</span><span style="color:#710">&quot;</span></span>) {&#10;                                                m1p1serve.innerHTML = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">S</span><span style="color:#710">&quot;</span></span>;&#10;                                                m1p2serve.innerHTML = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#710">&quot;</span></span>;&#10;                                        } <span style="color:#080;font-weight:bold">else</span> {&#10;                                                m1p1serve.innerHTML = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#710">&quot;</span></span>;&#10;                                                m1p2serve.innerHTML = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">S</span><span style="color:#710">&quot;</span></span>;&#10;                                        }&#10;                                        ..&#10;                                }&#10;                                ...&#10;                        } <span style="color:#080;font-weight:bold">catch</span> (exception) {&#10;                                data = msg.data;&#10;                                console.log(data);&#10;                        }&#10;                }&#10;        }&#10;}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Choix du protocole WS selon le type de protocole HTTP utilisé (sécurisé ou non)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Test du support par le navigateur de l&#8217;API WebSocket</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Création du WebSocket</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Sur l&#8217;Event-Handler <code>onmessage</code> , traitement du flux JSON reçu via le <em>peer serveur</em></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Test du type d&#8217;objet reçu (Match ou Pari) afin de réaliser le traitement adéquat avec le DOM</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Pour savoir quels sont les <strong>navigateurs compatibles avec l&#8217;API WebSocket</strong>, <a href="http://caniuse.com/#search=websocket">consultez le site caniuse.com</a>. Aujourd&#8217;hui, les dernières versions des navigateurs sont compatibles exceptées pour Opéra mini et Android Browser, qui représentent, à eux deux, seulement 3% du traffic web.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="sources-de-l-exemple-sur-github">Sources de l&#8217;exemple sur Github</h3>
<div class="paragraph">
<p>Vous pouvez <strong>forker le code sur Github</strong> à l&#8217;URL <code><strong><a href="https://github.com/mgreau/javaee7-websocket">https://github.com/mgreau/javaee7-websocket</a></strong></code></p>
</div>
<div class="paragraph">
<p>Cette application exemple est très basique, les idées d&#8217;améliorations possibles sont nombreuses : gérer un tournoi avec plusieurs matchs, parier sur d&#8217;autres critères, voir en live les paris des autres internautes&#8230;</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>Une feature, qui serait particulièrement intéressante techniquement, serait de créer un nouveau type de pari sur <strong>la zone de terrain des points gagnants</strong>. Il suffit de dessiner le terrain grâce à l&#8217;API HTML5 Canvas et de gérer les coordonnées de l&#8217;emplacement cliqué par l&#8217;internaute (comme zone gagnante) puis de les comparer aux coordonnées réelles lors d&#8217;un point gagnant.</em></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="construire-et-d-ployer-le-war">Construire et Déployer le WAR</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Pré-requis :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JDK 7</p>
</li>
<li>
<p>Apache Maven 3.0.4+</p>
</li>
<li>
<p>Serveur d&#8217;applications Java EE 7 : Wildfly 8 ou Glassfish 4</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Pour créer l&#8217;archive WAR, il suffit d&#8217;executer la commande Apache Maven ci-dessous ;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="text language-text">mvn clean package</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si vous utilisez Wildfly, le déploiement est automatique (le serveur doit être démarré) avec la commande ci-dessous :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="text language-text">mvn jboss-as:deploy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il suffit ensuite d&#8217;accéder à l&#8217;URL : <a href="http://localhost:8080/usopen/">http://localhost:8080/usopen/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="performances-websocket-vs-rest">Performances : WebSocket vs REST</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Afin d&#8217;avoir des métriques concernant les performances de ce nouveau protocole, Arun Gupta a developpé <a href="https://github.com/arun-gupta/javaee7-samples/tree/master/websocket/websocket-vs-rest">une application qui permet de comparer les temps d&#8217;execution</a> d&#8217;un même traitement réalisé avec du code développé en utilisant les technologies WebSocket et REST.</p>
</div>
<div class="paragraph">
<p>Les 2 endpoints de l&#8217;application (REST Endpoint et WebSocket Endpoint) ne font que renvoyer le flux qu&#8217;ils recoivent. L&#8217;interface Web de cette application permet de définir la taille du message et le nombre de fois que ce message doit être envoyé avant la fin du test.</p>
</div>
<div class="paragraph">
<p>Les résultats de ses tests, présentés ci-dessous, sont éloquents :</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;"> 
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type de Requête</th>
<th class="tableblock halign-left valign-top">Temps execution<br>
<strong>REST Endpoint</strong></th>
<th class="tableblock halign-left valign-top">Temps execution<br>
<strong>WebSocket Endpoint</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Envoi de 10 messages de 1 byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">220 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7 ms</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Envoi de 100 messages de 10 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">986 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">57 ms</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Envoi de 1000 messages de 100 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 210 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">179 ms</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Envoi de 5000 messages de 1000 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">54 449 ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1202 ms</p></td>
</tr>
</tbody>
</table>

</div>
</div>
<div class="sect1">
<h2 id="r-f-rences-pour-tout-savoir-sur-les-websocket">Références pour tout savoir sur les WebSocket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Je vous recommande plus particulièrement les conférences d' <a href="https://twitter.com/arungupta">Arun Gupta</a>, qui vous permettent, en moins d&#8217;1 heure, de tout connaître/comprendre sur la technologie WebSocket en général et sur l&#8217;API Java en particulier.<br>
Pour des informations plus avancées, l&#8217;idéal reste les spécifications IETF, W3C et Java.</p>
</div>
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a href="http://tools.ietf.org/html/rfc6455">RFC 6455: The WebSocket Protocol</a> - <em>Spécification IETF</em></p>
</li>
<li>
<p><a href="http://w3.org/TR/websockets/">W3C: The WebSocket API</a> - <em>Spécification W3C</em> (Candidate Recommandation)</p>
</li>
<li>
<p><a href="http://jcp.org/en/jsr/detail?id=356">JSR 356: Java API for WebSocket Protocol</a> - <em>Spécification Java</em></p>
</li>
<li>
<p><a href="https://glassfish.java.net/adoptajsr/jsr356.html">Adopt a JSR - JSR 356</a></p>
</li>
<li>
<p><a href="http://www.youtube.com/watch?v=QqbuDFIT5To">Java EE 7 &amp; WebSocket API</a> - <em>Conférence Arun Gupta SF</em> (à partir de la 46e minute)</p>
</li>
<li>
<p><a href="http://www.parleys.com/play/51c1cceae4b0ed8770356828/chapter4/about">Getting Started with WebSocket and SSE</a> - <em>Conférence Arun Gupta Devoxx UK 2013</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Cet article a été structuré en se basant sur la conférence Devoxx UK 2013.</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cet article a introduit, grâce à un exemple concret, <strong>le protocole WebSocket, l&#8217;API WebSocket HTML5 et l&#8217;API Java pour les WebSocket sortie avec Java EE 7</strong>. Il était déjà possible d&#8217;utiliser les WebSocket en Java grâce à des frameworks comme Atmosphere mais il manquait un standard.<br>
Aujourd&#8217;hui tous <strong>les standards sont finalisés ou en passe de l'être</strong>, cette nouvelle technologie répond à un besoin précis et est prometteuse en terme de performance. Pour qu&#8217;elle soit massivement utilisée, il faudra tout de même que ce protocole soit autorisée dans les entreprises là où bien souvent seul le protocole HTTP est disponible.</p>
</div>
</div>
</div><footer class="entry-footer"><div class="tags"><a href="/posts/tags/javaee7"><span class="label">javaee7</span></a><a href="/posts/tags/javaee"><span class="label">javaee</span></a><a href="/posts/tags/websocket"><span class="label">websocket</span></a><a href="/posts/tags/html5"><span class="label">html5</span></a><a href="/posts/tags/wildfly"><span class="label">wildfly</span></a></div></footer><div id="comments">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
            var disqus_shortname = 'mgreau';
            var disqus_url = "http://mgreau.com/posts/2013/09/27/javaee7-api-websocket-html5.html";
            var disqus_developer = null;
            var disqus_identifier = "948b3a01de4bcd136dd5f629ebab4788505486cb";
            (function() {
              var dsq = document.createElement("script"); dsq.type = "text/javascript"; dsq.async = true;
              dsq.src = "http://mgreau.disqus.com/embed.js";
              (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(dsq);
            })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=mgreau">comments powered by Disqus.</a></noscript>
          </div></article></div></div><footer id="footer"><div class="container"><div class="row-fluid pull-center"><div id="contact" class="social-media"><a title="My Twitter account - @mgreau" href="https://twitter.com/mgreau"><i class="icomoon-twitter-3"></i></a><a title="My G+ account"  href="https://plus.google.com/u/0/110674805154532168093/posts/p/pub"><i class="icomoon-google-plus-4"></i></a><a title="My Github account - mgreau"  href="https://github.com/mgreau"><i class="icomoon-github-3"></i></a><a title="My LinkedIn account"  href="https://fr.linkedin.com/in/mgreau"><i class="icomoon-linkedin"></i></a></div><p>Copyright 2013 © <a href="http://mgreau.com">mgreau.com</a> | Baked by Awestruct - Asciidoc</p></div></div>  </footer><script type="text/javascript"></script><script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount','UA-20147445-1']);
_gaq.push(['_trackPageview']);
(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<script src="/javascripts/jquery.js"></script><script src="/javascripts/bootstrap.min.js"></script><script src="/plugins/flexslider/jquery.flexslider-min.js"></script><script src="/plugins/jPanelMenu/jquery.jpanelmenu.min.js"></script><script src="/plugins/jRespond/js/jRespond.js"></script><script src="/plugins/onePageNav/jquery.scrollTo.js"></script><script src="/plugins/onePageNav/jquery.nav.js"></script><script src="/javascripts/script.js"></script></body></html>