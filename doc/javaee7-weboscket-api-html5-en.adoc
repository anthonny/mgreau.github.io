= Java EE 7 and WebSocket API for Java (JSR 356) 
Maxime Gréau - http://mgreau.com
2013-09-27
:toc:
:toc-placement: preamble
:toc-title: Table des matières de l'article
:source-highlighter: coderay
:imagesdir: ../posts/images
:experimental:
:mdash: &#8212;
:language: asciidoc
:link-demo: http://wildfly-mgreau.rhcloud.com/usopen/
:link-html-fr: http://mgreau.com/posts/2013/09/27/javaee7-api-websocket-html5.html
:link-html-en: http://mgreau.com/posts/2013/10/23/javaee7-api-websocket-html5-en.html
:link-pdf-fr: http://mgreau.com/doc/javaee7-api-websocket-html5.pdf
:link-pdf-en: http://mgreau.com/doc/javaee7-api-websocket-html5-en.pdf
:link-javaee7: http://jcp.org/en/jsr/detail?id=342
:link-jsr356: http://jcp.org/en/jsr/detail?id=356
:link-adoptjsr-jsr356: https://glassfish.java.net/adoptajsr/jsr356.html
:link-w3c-api: http://w3.org/TR/websockets/
:link-rfc6455: http://tools.ietf.org/html/rfc6455
:link-rfc2616: http://tools.ietf.org/html/rfc2616
:link-rfc2616-upgrade: http://tools.ietf.org/html/rfc2616#section-14.42
:link-arungupta-devoxxuk: http://www.parleys.com/play/51c1cceae4b0ed8770356828/chapter4/about
:link-arungupta-jugsf: http://www.youtube.com/watch?v=QqbuDFIT5To
:link-arungupta-twitter: https://twitter.com/arungupta
:link-javaone2013-keynote: https://blogs.oracle.com/javaone/entry/the_javaone_2013_technical_keynote

[NOTE]
.Overview
====
This blog post describes the *{link-jsr356}[Java API for WebSocket Protocol (JSR 356)]*, which is one of four newest JSRs for the *{link-javaee7}[Java EE 7]* platform, and provides a concrete application {link-demo}[available online on OpenShift].

* {link-pdf-en}[Download an English PDF version]
* {link-html-fr}[Read a French HTML version] or {link-pdf-fr}[download a French PDF Version]
====

Once you will have read this post, you will be able to understand {link-arungupta-twitter}[Arun Gupta]'s definition about what is it possible to do with WebSocket technology.

----
"WebSocket gives you bidirectionnal, full duplex, communication channel over a single TCP."
-- Arun Gupta (Java EE Evangelist chez Oracle) - Devoxx UK 2013
----

== Java EE 7 overview
The *Java Platform Enterprise Edition* was released in Version 7 (Java EE 7) in *June 2013*.
In line with the two previous versions (Java EE 5 and Java EE 6) *Java EE 7* always proposes to simplify the work of the developer.
This version decorates previous versions with 3 main objectives :

* embraces *HTML5* (WebSocket API, JSON-P API, JAX-RS)
* provide an *even better productivity* to developer (JMS)
* meeting *enterprise demands* (Batch API, Concurrency Utilities)

[[javaee7_intro]]
.The 3 goals of Java EE 7
image::javaee7_intro.png[Java EE 7 goals]

Java Platform, Entreprise Edition 7 (JSR 342) can be summmed up around :

* 4 newest specifications : *+Java API for WebSocket 1.0+*, *+Java API for JSON Processing 1.0+* , *+Batch Applications 1.0+* and *+Concurrency Utilities for Java EE 1.0+*
* 3 specifications with major updates : *+JMS 2.0+*, *+JAX-RS 2.0+* and *+EL 3.0+*	
* and 6 specifications with minor updates : *+JPA 2.1+*, *+Servlet 3.1+*, *+EJB 3.2+*, *+CDI 1.1+*, *+JSF 2.2+* and *+Bean Validation 1.1+*


== DEMO : HTML5/JSR-356 API application deployed on Wildfly 8 (OpenShift)

If you want to see right away what it looks like, you can access +{link-demo}[the online application]+ whose code will be in part explained in this article.
It's an application that give you the ability :

* to follow a tennis match in *live mode* (Final U.S. Open 2013) without any action other than the first connection to the URL
* to bet on the winner of the match

You will say: '"Nothing special"', and you are right :)

At first glance, it sounds like something already seen in many of today's applications, but it's the technique used behind which does matter because, as you will see below, everything is based around the *standard of the new WebSocket protocol (ws:// ou wss://)* and not on the "hacking" of HTTP.

[NOTE]
.The technologies used for the development of this application are : 
====
* Frontend : +HTML5+, +CSS+, +Javascript (WebSocket API)+ with 'Bootstrap CSS but without JQuery and BootstrapJS'
* Backend : +Java API for WebSocket+, +EJB+, +JSON-P+
====

[[websocket_example]]
.Implementation of WebSocket (Java API et Javascript API)
image::websocket_example.png[Implementation of WebSocket (Java API et Javascript API), link="{link-demo}"]

Nope! This demonstration is *not a chat application :)*
It's obvious that the "chat demo" is the one that first comes to mind to illustrate the use of WebSocket technology. However, there are many other use cases, such as collaborative work on a text document online or online games like chess presented at the {link-javaone2013-keynote}[JavaOne 2013 keynote].

[TIP]
====
'This application is available on the Cloud thanks to https://www.openshift.com/[OpenShift], the cloud computing PaaS product by RedHat. It's deployed on WildFly 8.0.0-Beta3 (normaly certified Java EE 7 to the end of 2013). To set up an application server like WildFly on OpenShit, you just need to read https://www.openshift.com/blogs/deploy-websocket-web-applications-with-jboss-wildfly[this Shekhar Gulati's blog post]'
====

== WebSocket (WS) : a new protocol different from HTTP

{link-rfc2616}[HTTP] is the standard protocol for the Web, it's very effective for a lot of use cases but, nevertheless, has *some drawbacks* in the case of *interactive Web applications* :

* *half-duplex* : based on the request/response pattern, the client sends a request and the server performs processing before sending a response, the client is forced to wait for a server response
* *verbose* : a lot of information are send in HTTP headers associated with the message, both in the HTTP request and in the HTTP response
* in order to add a *server push* mode, you need to use workaround (polling, long polling, Comet/Ajax) since there is no standard

This protocol is not optimized to scale on large applications that have significant needs of real-time bi-directional communication. This is why the *new WebSocket protocol* offers more advanced features than HTTP because it is:

* based on *+1 unique TCP connection between 2 peers+* (whereas each HTTP request/response needs a new TCP connection)
* *+bidirectionnal+* : client can send message to server and server can also send message to client
* *+full-duplex+* : client can send multiple messages to server, as well as server to client without waiting for a response from each other

[WARNING]
====
'The term *client* is used only to define the one that initiate the connection. Once the connection is established, client and server become both *peers*, with the same capacity.'
====

The WebSocket protocol was originally intended to be part of the HTML5 specification but as HTML5 will be officially released in 2014, the WebSocket protocol is finally set, as well as HTTP protocol, by an IETF specification, {link-rfc6455}[la RFC 6455].

As shown in the diagram below, the *WebSocket protocol works in two phases* named :

. *+handshake+*
. *+data transfer+*

[[websocket_protocol]]
.How does the WebSocket protocol work
image::WebSocket_Protocol.png[Diagram which explain how does the WebSocket protocol work,550]

=== Handshake
La phase nommée *Handshake* correspond à un *unique échange requête/réponse HTTP* entre l'initiateur de la connexion (peer client)  et le peer serveur. Cet échange HTTP est spécifique car il utilise la notion {link-rfc2616-upgrade}[*d'Upgrade, définie dans la spécification HTTP*.] + 
Le principe est simple : *l'Upgrade HTTP* permet au client de communiquer avec le serveur pour lui demander de changer de protocole de communication et ainsi faire en sorte que le client et le serveur utilisent un protocole autre que HTTP pour discuter.

[[eg1-callouts]]
.HTTP Handshake request sample
====
[source, text]
----
GET /usopen/matches/1234 HTTP/1.1     # <1>
Host: wildfly-mgreau.rhcloud.com:8000  # <2>	
Upgrade: websocket  # <3>
Connection: Upgrade # <4>
Origin: http://wildfly-mgreau.rhcloud.com
Sec-WebSocket-Key:0EK7XmpTZL341oOh7x1cDw==
Sec-WebSocket-Version:13
----
<1> HTTP GET method and HTTP 1.1 version required
<2> Host used for the WebSocket connection
<3> Request to upgrade to the WebSocket protocol
<4> Request to upgrade from HTTP to another protocol

====

[[eg2-callouts]]
.HTTP Handshake Response sample
====
[source, text]
---- 
HTTP/1.1 101 Switching Protocols # <1>
Connection:Upgrade
Sec-WebSocket-Accept:SuQ5/hh0kStSr6oIzDG6gRfTx2I=
Upgrade:websocket <2>
----
<1> HTTP Response Code 101 : server is compatible and accept to send messages through another protocol
<2> Upgrade to the WebSocket protocol is accepted
====

[IMPORTANT]
====
'When the upgrade request from HTTP to WebSocket protocol is approved by the endpoint server, it's no longer possible to use HTTP communication, all exchanges have to be made through the WebSocket protocol.'
====

=== Data transfer
Once the *handshake* is approved, the use of WebSocket protocol is established. There are an open connection on the 'peer server side' as well on the 'peer client side', callback handlers are called to initiate the communication. + 
The *Data transfer* can now begin, so the 2 peers can exchange messages in a bidirectionnal and full-duplex communication.

As shown in the diagram named *Figure 3*, the +peer server+ can send multiple messages (in this example : 1 message to each point of the game) without any +peer client+ response and the peer client can also send messages at any time (in this example : betting on the winner of the match).
Each peer can send a specific message to close the connection. +

With Java EE7 Platform, the +peer server side+ code is written in *Java* while the +peer client side+ code is in *Java or Javascript*.

== WebSocket Javascript API (Client)

Pour communiquer à partir d'une application Web avec un serveur en utilisant le protocole WebSocket, il est nécessaire d'utiliser *une API cliente en Javascript*. C'est le W3C qui définit cette API. + 
La spécification W3C de cette {link-w3c-api}[API Javascript pour WebSocket] est en cours de finalisation. http://www.w3.org/TR/websockets/#websocket[L'interface WebSocket] propose, entre-autres, les éléments suivants :

* un attribut pour l'URL de connexion au server Endpoint (+url+)
* un attribut sur l'état de la connexion (+readyState+ : CONNECTING, OPEN, CLOSING, CLOSED)
* des *Event Handler (gestionnaire d'évènement)* pour s'adapter aux méthodes du cycle de vie des WebSocket, par exemple : 
** the Event Handler +onopen+ is called when a new connection is open
** the Event Handler +onerror+ is called when an error occured during the communication
** the Event Handler +onmessage+ is called when a message arrives from the server
* les méthodes (+send(DOMString data)+, +send(Blob data)+) avec lesquelles il est possible d'envoyer différents types de flux (texte, binaire) vers le serveur Endpoint


[[eg3-callouts]]
.Javascript source code example, from http://websocket.org
====
[source, javascript]
---- 
var wsUri = "ws://echo.websocket.org/"; 

function testWebSocket() { 

	websocket = new WebSocket(wsUri); 
	websocket.onopen = function(evt) { onOpen(evt) }; 
	websocket.onclose = function(evt) { onClose(evt) }; 
	websocket.onmessage = function(evt) { onMessage(evt) }; 
	websocket.onerror = function(evt) { onError(evt) }; }  
}

function onOpen(evt) { 
	writeToScreen("CONNECTED"); 
	doSend("WebSocket rocks"); 
}  
function onClose(evt) { 
	writeToScreen("DISCONNECTED"); 
}  
function onMessage(evt) { 
	writeToScreen('<span style="color: blue;">RESPONSE: ' + evt.data+'</span>'); 
	websocket.close(); 
}  

function onError(evt) { 
	writeToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
}  
function doSend(message) { 
	writeToScreen("SENT: " + message);  
	websocket.send(message); 
}
----
====

== JSR 386 : Java API for WebSocket protocol

Le W3C définit donc comment utiliser WebSocket en Javascript, le *Java Communitee Process (JCP)* fait de même pour le monde Java via la JSR 386 . + 
La JSR 356 définit ainsi une {link-jsr356}[API Java pour WebSocket] qui propose :

* la création d'un +*WebSocket Endpoint*+ (serveur ou client), nom donné au composant Java capable de communiquer via le protocole WebSocket
* la possibilité d'utiliser l'approche par *annotation Java* ou par programmation
* la possibilité *d'envoyer et de consommer des messages* de contrôles, textuels ou binaires via ce protocole
** de gérer le message en tant que message complet ou par une séquence de messages partiels
** envoyer ou recevoir les messages en tant qu'objets Java (notion d'*encoders/decoders*)
** envoyer les messages *en synchrone ou en asynchrone*
* la configuration et la *gestion des sessions WebSocket* (timeout, cookies...)
* une intégration dans *Java EE Web Profile*

NOTE: 'L'implémentation de référence Java pour l'API WebSocket est https://tyrus.java.net/[le projet Tyrus]'

=== WebSocket Server Endpoint

La transformation d'un Plain Old Java Object (POJO) vers un *WebSocket Endpoint* de type serveur (c'est-à-dire capable de gérer des requêtes de plusieurs clients sur une même URI) est *extrêment simple*, puisqu'il suffit d'annoter la classe avec *@ServerEndpoint* et une méthode du POJO avec *@OnMessage* :
====
[source, java]
----
import javax.websocket.OnMessage;
import javax.websocket.ServerEndpoint;

@ServerEndpoint("/echo") // <1>
public class EchoServer {

	@OnMessage // <2>
	public String handleMessage(String message){
		return "Thanks for the message: " + message;
	}

}
----
<1> L'annotation @ServerEndpoint transforme le POJO en WebSocket Endpoint, l'attribut *value* est obligatoire afin de préciser l'URI d'accès à cet Endpoint
<2> la méthode handleMessage sera évoquée lors de chaque message reçu
====

=== Annotations
L'API met à disposition plusieurs types d'annotations afin d'être entièrement compatible avec le procotole WebSocket :

[cols="2", options="header"] 
|===
|Annotation
|Rôle
|@ServerEndpoint
|Déclare un Server Endpoint
|@ClientEndpoint
|Déclare un Client Endpoint
|@OnOpen
|Défini la méthode appelée pour gérer l'évenement d'ouverture de la connexion
|@OnMessage
|Défini la méthode appelée pour gérer l'évenement de réception d'un message
|@OnError
|Défini la méthode appelée pour gérer l'évenement lors d'une erreur
|@OnClose
|Défini la méthode appelée pour gérer l'évenement de clôture de la connexion
|===

Les attributs de l'annotation +@ServerEndpoint+ sont les suivants :

value:: URI relative ou URI template (ex: "/echo", "/chat/{subscriver-level}")
decoders:: liste de noms de classes utilisées pour décoder les messages entrants
encoders:: liste de noms de classes utilisées pour encoder les messages sortants
subprotocols:: liste de sous-protocoles autorisés (ex: http://wamp.ws)

=== Encoders and Decoders

Comme il a été décrit plus tôt dans cet article, le serveur Endpoint peut recevoir différents types de contenu dans les messages : des données au format texte (JSON, XML...) ou au format binaire. + 
Afin de gérer efficacement les messages provenant des 'peers client' ou à destination de ceux-ci dans le code métier de l'application, il est possible de créer des classes Java de type *Decoders et Encoders*.

Quelque soit l'algorithme de transformation, il va alors être possible de transformer  :

* le POJO métier vers un flux au format désiré pour l'envoi (JSON, XML, Binaire...)
* les flux entrants dans format spécfique (JSON, XML..) vers le POJO métier

Ainsi, le code de l'application est organisé de telle façon que la logique métier n'est pas impactée par le type et le format de flux échangés entre le 'peer serveur' et les 'peers clients'.
Un exemple concret est présenté dans la suite de l'article.

=== WebSocket Client Endpoint

L'API propose donc également le support pour créer des Endpoints côté client en Java.

[[eg4-callouts]]
.Java Client Endpoint sample
====
[source, java]
----
@ClientEndpoint
public class HelloClient {

	@OnMessage 
	public String message(String message){
		// traitement
	}
}

WebSocketContainer c = ContainerProvider.getWebSocketContainer();
c.connectToServer(HelloClient.class, "hello");
----
====

== US OPEN Application

L'application exemple est déployée sous forme de WAR issue d'un projet Apache Maven.
Outre la gestion classique du cycle de vie WebSocket, le workflow d'envoi de messages est le suivant :

* à chaque point du match, les 'peers clients' recoivent les données du match (score, service...)
* le 'peer client' peut envoyer un message pour parier sur le gagnant du match
* à la fin du match, les 'peers clients' reçoivent un message contenant le nom du vainqueur

*Tous les messages sont échangés au format JSON.* + 

L'arborescence du projet est la suivante :

[[eg5-callouts]]
.Maven project structure
====
[source, text]
----
+ src/main/java
   |+ com.mgreau.wildfly.websocket
      |+ decoders       
         |- MessageDecoder.java   // <1>
      |+ encoders       // <2>
         |- BetMessageEncoder.java   
         |- MatchMessageEncoder.java 
      |+ messages       // <3>
         |- BetMessage.java
         |- MatchMessage.java
         |- Message.java
      |- MatchEndpoint.java    // <4>
      |- StarterService.java   // <5>
      |- TennisMatch.java      // <6>
+ src/main/resources
+ scr/main/webapp
   |+ css
   |+ images   
   |- index.html   
   |- websocket.js  // <7>
pom.xml		
----
<1> Decode le message JSON provenant du 'peer client' concernant le pari sur le vainqueur en POJO ('BetMessage')
<2> Encode à destination des 'peers clients', en JSON (via JSON-P), les messages contenant le détail du match et le résultat du pari sur le vainqueur
<3> POJOs représentant les types de messages échangés entre peers
<4> WebSocket Server Endpoint de l'application ('peer server')
<5> EJB @Startup permettant d'initialiser l'application lors du déploiement 
<6> POJO pour gérer les informations du match
<7> Fichier Javascript pour la communication WebSocket du 'peer client' via l'API Javascript
====

=== Maven dependencies for Java EE 7 API

[[eg6-callouts]]
.pom.xml with Java EE 7 dependencies
====
[source, xml]
----
<project>
...
<properties>
	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	<!-- Java EE 7 -->
	<javaee.api.version>7.0</javaee.api.version>
</properties

<dependencies>
	<dependency>
		<groupId>javax</groupId> <!--1-->
		<artifactId>javaee-api</artifactId>
		<version>${javaee.api.version}</version>
		<scope>provided</scope>
	</dependency>
</dependencies>
...
</project>
----
<1> il est important d'utiliser les dépendances de la spécification Java EE 7 afin de pouvoir déployer l'application dans plusieurs serveurs d'applications Java EE sans changement de code (Wildfly, Glassfish...)
====

=== Add Server Endpoint

Cet Endpoint permet de recevoir les messages concernant les paris sur le vainqueur du match et également d'envoyer aux 'peers clients' les informations du déroulement du match.

[[eg7-callouts]]
.Server Endpoint : MatchEndpoint.java
====
[source,java]
----
@ServerEndpoint( 						
		value = "/matches/{match-id}",  // <1>
		        decoders = { MessageDecoder.class }, // <2>
		        encoders = { MatchMessageEncoder.class, BetMessageEncoder.class } // <3>
		)
public class MatchEndpoint {

	private static final Logger logger = Logger.getLogger("MatchEndpoint");

	/* Queue for all open WebSocket sessions */
	static Queue<Session> queue = new ConcurrentLinkedQueue<>();

	@OnOpen
	public void openConnection(Session session, 
				@PathParam("match-id") String matchId) {	// <4>
	    /* Register this connection in the queue */
	    queue.add(session);
	    session.getUserProperties().put(matchId, true);
	    logger.log(Level.INFO, "Connection opened for game : " + matchId);
	}

	public static void send(MatchMessage msg, String matchId) {
	  try {
	    /* Send updates to all open WebSocket sessions for this match */
	    for (Session session : queue) {
    	  if (Boolean.TRUE.equals(session.getUserProperties().get(matchId))){
	        if (session.isOpen()){
		      session.getBasicRemote().sendObject(msg);	// <5>
		      logger.log(Level.INFO, "Score Sent: {0}", msg);
	        }
    	  }
	    }
	  } catch (IOException | EncodeException e) {
	    logger.log(Level.INFO, e.toString());
	  }   
	}

	@OnMessage
	public void message(final Session session, BetMessage msg) {	// <6>
	    logger.log(Level.INFO, "Received: Bet Match Winner - {0}", msg.getWinner());
	    session.getUserProperties().put("betMatchWinner", msg);
	}
...
}

----
<1>  URI pour accéder à cet Endpoint, comme le context-root de l'application est '/usopen', un exemple d'URL est +ws://<host>:<port>/usopen/matches/1234+
<2> la classe 'MessageDecoder' permet de transformer le flux JSON entrant pour le pari sur le vainqueur en POJO 'BetMessage'
<3> les 2 encodeurs permettent de transformer les POJO 'MatchMessage' et 'BetMessage' en flux JSON
<4> l'annotation +@PathParam+ permet ici d'extraire l'élément de la requête WS et de passer la valeur (identifiant du match) en paramètre de la méthode, il est ainsi possible de gérer plusieurs matchs avec des clients différents pour chaque match.
<5> Envoi du message concernant le match aux peers connectés, grâce à l''Encoder' il suffit de passer en paramètre un objet 'MatchMessage'
<6> Gestion de la réception des messages de pari sur le vainqueur du macth, grâce au 'Decoder' la méthode prend en paramètre un objet 'BetMessage'
====

=== Encodes and Decodes messages

Pour encoder ou décoder les messages échangés entre peers, il suffit d'implémenter l'interface adéquate selon le type de message (Texte, Binaire) et le sens de traitement (encodage, décodage), puis de redéfinir la méthode associée. + 
Dans l'exemple ci-dessous, il s'agit de l'encodeur pour le POJO MatchMessage vers le format JSON. L'API utilisée pour réaliser ce traitement est une des nouvelles API de Java EE 7 : http://jcp.org/en/jsr/detail?id=353[Java API for JSON Processiong (JSON-P)]

[[eg8-callouts]]
.Text Encoder : MatchMessageEncoder.java
====
[source, java]
--
public class MatchMessageEncoder implements Encoder.Text<MatchMessage> {

	@Override
	public String encode(MatchMessage m) throws EncodeException {
		StringWriter swriter = new StringWriter();
		try (JsonWriter jsonWrite = Json.createWriter(swriter)) {
			JsonObjectBuilder builder = Json.createObjectBuilder();
			builder.add(
				"match",
				Json.createObjectBuilder()
					.add("serve", m.getMatch().getServe())
					.add("title", m.getMatch().getTitle())
					...
			}

			jsonWrite.writeObject(builder.build());
		}
		return swriter.toString();
	}
}
--
====

=== HTML5 Web Client
L'unique page HTML de cette application charge le fichier *websocket.js* pour mettre en oeuvre l'API Javascript WebSocket et ainsi intéragir avec le Server Endpoint Java.

[[eg9-callouts]]
.API Javascript implemented into websocket.js
====
[source, javascript, options="nowrap"]
--
var wsUrl;
if (window.location.protocol == 'https:') {  // <1>
	wsUrl = 'wss://' + window.location.host + ':8443/usopen/matches/1234';
} else {
	wsUrl = 'ws://' + window.location.host + ':8000/usopen/matches/1234';
}

function createWebSocket(host) {
	if (!window.WebSocket) {    // <2>
	...
	} else {
		socket = new WebSocket(host);   // <3>
		socket.onopen = function() {
			document.getElementById("m1-status").innerHTML = 'CONNECTED...';
		};
		socket.onclose = function() {
			document.getElementById("m1-status").innerHTML = 'FINISHED';
		};
		...
		socket.onmessage = function(msg) {
			try { 
				console.log(data);
				var obj = JSON.parse(msg.data);     // <4>
				if (obj.hasOwnProperty("match")){   // <5>
					//title
					m1title.innerHTML = obj.match.title;
					// comments
					m1comments.value = obj.match.comments;
					// serve
					if (obj.match.serve === "player1") {
						m1p1serve.innerHTML = "S";
						m1p2serve.innerHTML = "";
					} else {
						m1p1serve.innerHTML = "";
						m1p2serve.innerHTML = "S";
					}
					..
				}
				...
			} catch (exception) {
				data = msg.data;
				console.log(data);
			}
		}
	}
} 
--
<1> Choix du protocole WS selon le type de protocole HTTP utilisé (sécurisé ou non)
<2> Test du support par le navigateur de l'API WebSocket
<3> Création du WebSocket
<4> Sur l'Event-Handler +onmessage+ , traitement du flux JSON reçu via le 'peer serveur'
<5> Test du type d'objet reçu (Match ou Pari) afin de réaliser le traitement adéquat avec le DOM
====

[NOTE]
====
Pour savoir quels sont les *navigateurs compatibles avec l'API WebSocket*, http://caniuse.com/#search=websocket[consultez le site caniuse.com]. Aujourd'hui, les dernières versions des navigateurs sont compatbiles exceptées pour Opéra mini et Android Browser, qui représentent, à eux deux, seulement 3% du traffic web. 
====

=== Source code on Github
Vous pouvez *forker le code sur Github* à l'URL +*https://github.com/mgreau/javaee7-websocket*+

Cette application exemple est très basique, les idées d'améliorations possibles sont nombreuses : gérer un tournoi avec plusieurs matchs, parier sur d'autres critères, voir en live les paris des autres internautes...

[TIP]
====
'Une feature, qui serait particulièrement intéressante techniquement, serait de créer un nouveau type de pari sur *la zone de terrain des points gagnants*. Il suffit de dessiner le terrain grâce à l'API HTML5 Canvas et de gérer les coordonnées de l'emplacement cliqué par l'internaute (comme zone gagnante) puis de les comparer aux coordonnées réelles lors d'un point gagnant.'
====

=== Build and Deploy the WAR

[IMPORTANT]
====
Pré-requis : 

* JDK 7
* Apache Maven 3.0.4+
* Java EE 7 Application Server : Wildfly 8 ou Glassfish 4
====
In order to build the WAR, you just have to execute the Maven command below ;
[source, text]
--
mvn clean package
--

If your application server is WildFly, you can quickly deploy the WAR with the command below (WildFly has to be started) :

[source, text]
--
mvn jboss-as:deploy
--

The usopen application is then available at : http://localhost:8080/usopen/

== Benchmark : WebSocket VS REST over HTTP
Afin d'avoir des métriques concernant les performances de ce nouveau protocole, Arun Gupta a developpé https://github.com/arun-gupta/javaee7-samples/tree/master/websocket/websocket-vs-rest[une application qui permet de comparer les temps d'execution] d'un même traitement réalisé avec du code développé en utilisant les technologies WebSocket et REST.

Les 2 endpoints de l'application (REST Endpoint et WebSocket Endpoint) ne font que renvoyer le flux qu'ils recoivent. L'interface Web de cette application permet de définir la taille du message et le nombre de fois que ce message doit être envoyé avant la fin du test.

The benchmark results, shown below, are quite eloquent :

[cols="3*", options="header"] 
|===
|Type de Requête
|Temps execution + 
*REST Endpoint*
|Temps execution +
*WebSocket Endpoint*
|Envoi de 10 messages de 1 byte
|220 ms
|7 ms
|Envoi de 100 messages de 10 bytes
|986 ms
|57 ms
|Envoi de 1000 messages de 100 bytes
|10 210 ms
|179 ms
|Envoi de 5000 messages de 1000 bytes
|54 449 ms
|1202 ms
|===


== References about WebSocket
Je vous recommande plus particulièrement les conférences d' {link-arungupta-twitter}[Arun Gupta], qui vous permettent, en moins d'1 heure, de tout connaître/comprendre sur la technologie WebSocket en général et sur l'API Java en particulier. + 
Pour des informations plus avancées, l'idéal reste les spécifications IETF, W3C et Java.

[bibliography]
- {link-rfc6455}[RFC 6455: The WebSocket Protocol] - 'Spécification IETF'
- {link-w3c-api}[W3C: The WebSocket API] - 'Spécification W3C' (Candidate Recommandation)
- {link-jsr356}[JSR 356: Java API for WebSocket Protocol] - 'Spécification Java'
- {link-adoptjsr-jsr356}[Adopt a JSR - JSR 356]
- {link-arungupta-jugsf}[Java EE 7 & WebSocket API] - 'Conférence Arun Gupta SF' (à partir de la 46e minute)
- {link-arungupta-devoxxuk}[Getting Started with WebSocket and SSE] - 'Conférence Arun Gupta Devoxx UK 2013'

'Cet article a été structuré en se basant sur la conférence Devoxx UK 2013.'

== Conclusion

Cet article a introduit, grâce à un exemple concret, *le protocole WebSocket, l'API WebSocket HTML5 et l'API Java pour les WebSocket sortie avec Java EE 7*. Il était déjà possible d'utiliser les WebSocket en Java grâce à des frameworks comme Atmosphere mais il manquait un standard. + 
Aujourd'hui tous *les standards sont finalisés ou en passe de l'être*, cette nouvelle technologie répond à un besoin précis et est prometteuse en terme de performance. Pour qu'elle soit massivement utilisée, il faudra tout de même que ce protocole soit autorisée dans les entreprises là où bien souvent seul le protocole HTTP est disponible.

